<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSOP Storage Node</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fira+Code&display=swap');
        .mono { font-family: 'Fira Code', monospace; }
        .pulse-dot {
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen">
    
    <div class="bg-gradient-to-r from-green-600 to-blue-600 p-6 shadow-2xl">
        <div class="max-w-6xl mx-auto">
            <div class="flex items-center justify-between">
                <div>
                    <h1 class="text-3xl font-black mb-1">üåê CSOP Storage Node</h1>
                    <p class="text-green-100 text-sm">IndexedDB as a Service</p>
                </div>
                <div class="flex items-center gap-3">
                    <div class="w-3 h-3 bg-green-500 rounded-full pulse-dot"></div>
                    <span class="text-sm font-bold">ACTIVE</span>
                </div>
            </div>
            <div class="mt-4 bg-black/30 p-3 rounded-lg">
                <div class="text-xs text-green-300 mb-1">API Endpoint:</div>
                <div class="mono text-sm" id="api-endpoint"></div>
            </div>
        </div>
    </div>

    <div class="max-w-6xl mx-auto p-6 space-y-6">
        <div class="grid grid-cols-4 gap-4">
            <div class="bg-gray-800 p-4 rounded-xl border border-gray-700">
                <div class="text-3xl font-black text-green-400" id="stat-documents">0</div>
                <div class="text-xs text-gray-400">Documents</div>
            </div>
            <div class="bg-gray-800 p-4 rounded-xl border border-gray-700">
                <div class="text-3xl font-black text-blue-400" id="stat-requests">0</div>
                <div class="text-xs text-gray-400">Requ√™tes</div>
            </div>
            <div class="bg-gray-800 p-4 rounded-xl border border-gray-700">
                <div class="text-3xl font-black text-purple-400" id="stat-storage">0</div>
                <div class="text-xs text-gray-400">MB</div>
            </div>
            <div class="bg-gray-800 p-4 rounded-xl border border-gray-700">
                <div class="text-3xl font-black text-pink-400" id="stat-uptime">0s</div>
                <div class="text-xs text-gray-400">Uptime</div>
            </div>
        </div>

        <div class="bg-gray-800 p-6 rounded-xl border border-gray-700">
            <h2 class="text-xl font-bold mb-4">üìä Latest Response</h2>
            <pre id="response" class="bg-gray-900 border border-gray-700 rounded p-4 text-sm mono overflow-x-auto text-green-400 min-h-24"></pre>
        </div>

        <div class="bg-gray-800 p-6 rounded-xl border border-gray-700">
            <h2 class="text-xl font-bold mb-4">üìù Activity Logs</h2>
            <div id="logs" class="space-y-1 text-xs mono max-h-64 overflow-y-auto"></div>
        </div>
    </div>

    <script>
        const STATS = { documents: 0, requests: 0, storage: 0, startTime: Date.now() };
        
        const DB = {
            name: 'csop_storage',
            version: 1,
            db: null,

            async init() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(DB.name, DB.version);
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => {
                        DB.db = request.result;
                        resolve(DB.db);
                    };
                    request.onupgradeneeded = (e) => {
                        const db = e.target.result;
                        if (!db.objectStoreNames.contains('storage')) {
                            const store = db.createObjectStore('storage', { keyPath: 'fullKey' });
                            store.createIndex('collection', 'collection', { unique: false });
                        }
                    };
                });
            },

            async write(collection, key, data) {
                const fullKey = `${collection}:${key}`;
                const doc = { fullKey, collection, key, data, timestamp: Date.now() };
                const tx = DB.db.transaction('storage', 'readwrite');
                const store = tx.objectStore('storage');
                return new Promise((resolve, reject) => {
                    const request = store.put(doc);
                    request.onsuccess = () => resolve({ success: true, key: fullKey });
                    request.onerror = () => reject(request.error);
                });
            },

            async read(collection, key) {
                const fullKey = `${collection}:${key}`;
                const tx = DB.db.transaction('storage', 'readonly');
                const store = tx.objectStore('storage');
                return new Promise((resolve, reject) => {
                    const request = store.get(fullKey);
                    request.onsuccess = () => {
                        if (request.result) {
                            resolve({ success: true, data: request.result.data });
                        } else {
                            reject(new Error('Key not found'));
                        }
                    };
                    request.onerror = () => reject(request.error);
                });
            },

            async list(collection) {
                const tx = DB.db.transaction('storage', 'readonly');
                const store = tx.objectStore('storage');
                const index = store.index('collection');
                return new Promise((resolve, reject) => {
                    const request = index.getAll(collection);
                    request.onsuccess = () => {
                        resolve({ 
                            success: true, 
                            count: request.result.length,
                            data: request.result.map(doc => ({
                                key: doc.key,
                                data: doc.data,
                                timestamp: doc.timestamp
                            }))
                        });
                    };
                    request.onerror = () => reject(request.error);
                });
            },

            async delete(collection, key) {
                const fullKey = `${collection}:${key}`;
                const tx = DB.db.transaction('storage', 'readwrite');
                const store = tx.objectStore('storage');
                return new Promise((resolve, reject) => {
                    const request = store.delete(fullKey);
                    request.onsuccess = () => resolve({ success: true });
                    request.onerror = () => reject(request.error);
                });
            },

            async count() {
                const tx = DB.db.transaction('storage', 'readonly');
                const store = tx.objectStore('storage');
                return new Promise((resolve) => {
                    const request = store.count();
                    request.onsuccess = () => resolve(request.result);
                });
            }
        };

        async function handleRequest(urlParams) {
            STATS.requests++;
            updateStats();

            const action = urlParams.get('action');
            const collection = urlParams.get('collection');
            const key = urlParams.get('key');
            const bodyParam = urlParams.get('body');

            log(`üì° ${action?.toUpperCase()} ${collection || '?'}:${key || '*'}`, 'info');

            try {
                let body = null;
                if (bodyParam) {
                    body = JSON.parse(decodeURIComponent(bodyParam));
                }

                let result;

                switch (action) {
                    case 'write':
                        if (!body?.collection || !body?.key || !body?.data) {
                            throw new Error('Missing: collection, key, data');
                        }
                        result = await DB.write(body.collection, body.key, body.data);
                        break;
                    
                    case 'read':
                        if (!collection || !key) throw new Error('Missing: collection, key');
                        result = await DB.read(collection, key);
                        break;
                    
                    case 'list':
                        if (!collection) throw new Error('Missing: collection');
                        result = await DB.list(collection);
                        break;
                    
                    case 'update':
                        if (!body?.collection || !body?.key || !body?.data) {
                            throw new Error('Missing: collection, key, data');
                        }
                        result = await DB.write(body.collection, body.key, body.data);
                        break;
                    
                    case 'delete':
                        if (!collection || !key) throw new Error('Missing: collection, key');
                        result = await DB.delete(collection, key);
                        break;
                    
                    default:
                        throw new Error(`Invalid action: ${action}`);
                }

                log(`‚úÖ ${action.toUpperCase()} OK`, 'success');
                return result;

            } catch (error) {
                log(`‚ùå ${action?.toUpperCase()} FAILED: ${error.message}`, 'error');
                return { success: false, error: error.message };
            }
        }

        window.addEventListener('load', async () => {
            await DB.init();
            await updateStats();
            
            const urlParams = new URLSearchParams(window.location.search);
            const action = urlParams.get('action');

            if (action) {
                // Mode API: retourner JSON pur
                try {
                    const result = await handleRequest(urlParams);
                    
                    // Retourner UNIQUEMENT du JSON
                    document.body.innerHTML = `<pre style="color: #10b981; background: #0f172a; padding: 20px; font-family: 'Fira Code', monospace; margin: 0; min-height: 100vh;">${JSON.stringify(result, null, 2)}</pre>`;
                    
                } catch (error) {
                    document.body.innerHTML = `<pre style="color: #ef4444; background: #0f172a; padding: 20px; font-family: 'Fira Code', monospace; margin: 0; min-height: 100vh;">${JSON.stringify({ 
                        success: false, 
                        error: error.message 
                    }, null, 2)}</pre>`;
                }
            } else {
                // Mode interface normale
                document.getElementById('api-endpoint').textContent = window.location.href;
                log('üöÄ CSOP Storage Node ready', 'success');
                startUptimeCounter();
            }
        });

        async function updateStats() {
            STATS.documents = await DB.count();
            if ('storage' in navigator && 'estimate' in navigator.storage) {
                const est = await navigator.storage.estimate();
                STATS.storage = (est.usage / (1024 * 1024)).toFixed(2);
            }
            document.getElementById('stat-documents').textContent = STATS.documents;
            document.getElementById('stat-requests').textContent = STATS.requests;
            document.getElementById('stat-storage').textContent = STATS.storage;
        }

        function startUptimeCounter() {
            setInterval(() => {
                const uptime = Math.floor((Date.now() - STATS.startTime) / 1000);
                document.getElementById('stat-uptime').textContent = uptime + 's';
            }, 1000);
        }

        function log(message, type = 'info') {
            const logsDiv = document.getElementById('logs');
            const colors = { info: 'text-blue-400', success: 'text-green-400', error: 'text-red-400' };
            const logEntry = document.createElement('div');
            logEntry.className = colors[type];
            logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logsDiv.insertBefore(logEntry, logsDiv.firstChild);
            if (logsDiv.children.length > 50) logsDiv.removeChild(logsDiv.lastChild);
            
            // Afficher aussi dans response
            const responseDiv = document.getElementById('response');
            if (responseDiv) {
                responseDiv.textContent = message;
            }
        }
    </script>
</body>
</html>